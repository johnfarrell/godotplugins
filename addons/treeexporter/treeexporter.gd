@tool
extends EditorPlugin

const DockScene = preload("res://addons/treeexporter/ts_exporter_dock.tscn")
var dock_instance

func _enter_tree() -> void:
	dock_instance = DockScene.instantiate()
	
	var generate_button = dock_instance.get_node("generateButton")
	generate_button.pressed.connect(_on_generate_button_pressed)
	
	add_control_to_dock(DOCK_SLOT_RIGHT_UL, dock_instance)

func _exit_tree() -> void:
	remove_control_from_docks(dock_instance)
	if is_instance_valid(dock_instance):
		dock_instance.queue_free()

# --- Main Logic ---
func _on_generate_button_pressed():
	var editor_selection = get_editor_interface().get_selection()
	var selected_nodes = editor_selection.get_selected_nodes()
	
	var start_node: Node
	
	if not selected_nodes.is_empty():
		start_node = selected_nodes[0]
		print("ID Hierarchy: Starting from selected node '", start_node.name, "'")
	else:
		print("ID Hierarchy: Select a root node before generating heirarchy")
		return

	
	print("ID Hierarchy: Generating for node: ", start_node.scene_file_path)

	# 1. Traverse the tree and build a Godot Dictionary of relationships
	var hierarchy_dict = {}
	_collect_relationships(start_node, hierarchy_dict)

	# 2. Convert the Dictionary into a TypeScript constant string
	var ts_string = "/**\n"
	ts_string += " * This file is auto-generated by the Godot 'Scene to ID Hierarchy' plugin.\n"
	ts_string += " * Do not edit this file manually.\n"
	ts_string += " * Parent-child relationships for runtime object movement.\n"
	ts_string += " */\n\n"
	ts_string += "// Maps a parent object's SDK ID to an array of its children's SDK IDs.\n"
	ts_string += "export const SCENE_HIERARCHY: { [key: number]: number[] } = {\n"
	
	for parent_id in hierarchy_dict:
		var child_ids = hierarchy_dict[parent_id]
		# Format the array of numbers into a string like "[101, 102, 103]"
		var children_array_string = str(child_ids).replace(" ", "")
		ts_string += "  " + str(parent_id) + ": " + children_array_string + ",\n"
		
	ts_string += "};\n"
	
	var result_display = dock_instance.get_node_or_null("resultDisplay")
	if result_display:
		result_display.text = ts_string

	# 3. Save the file
	var output_path = "res://generated/scene_hierarchy.ts"
	save_file(output_path, ts_string)

# Recursively walks the scene tree, collecting nodes that have "sdk_id" metadata.
func _collect_relationships(node: Node, dict: Dictionary):
	# Check if the current node has an SDK ID. If not, we can't process it or its children.
	if not "ObjId" in node:
		# If it's the root node, we can still process its direct children
		if node != get_editor_interface().get_edited_scene_root():
			return
			
	var parent_id = node.ObjId
	var children_with_ids = []

	for child in node.get_children():
		if "ObjId" in child:
			var child_id = child.ObjId
			children_with_ids.append(child_id)
			
			# Continue the traversal down the tree
			_collect_relationships(child, dict)
	
	# Only add an entry if the parent has a valid ID and has children with IDs
	if parent_id != -1 and not children_with_ids.is_empty():
		dict[parent_id] = children_with_ids


# Helper to show messages to the user in the editor
func show_message(text: String, title: String):
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = text
	get_editor_interface().get_base_control().add_child(dialog)
	dialog.popup_centered()

# Helper for saving the file
func save_file(path: String, content: String):
	var dir_path = path.get_base_dir()
	DirAccess.make_dir_recursive_absolute(ProjectSettings.globalize_path(dir_path))
	
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file:
		file.store_string(content)
		print("ID Hierarchy: Successfully generated file at ", path)
		show_message("Hierarchy file generated successfully at:\n" + path, "Success")
	else:
		print("ID Hierarchy: Error writing file at ", path)
		show_message("Failed to write TypeScript file!", "Error")
